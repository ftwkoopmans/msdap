
#' volcano plot for DEA results, split into 4 panels; with/without labels and with/without thresholding foldchange-outliers
#'
#' If there are multiple contrasts in your DEA results, you should first subset the DEA result table for 1 contrast before calling this plot function (i.e. don't plot multiple contrasts into 1 volcano plot), see Example 5 below.
#'
#' @param stats_de typically these are the output generated by the MS-DAP dea() function. If you use the entire pipeline, i.e. analysis_quickstart(), the resulting dataset objects holds these in the dataset$de_proteins property. Include a column "gene_symbols_or_id" to plot gene symbols instead of protein_id, see examples below
#' @param log2foldchange_threshold threshold for significance of log2 foldchanges. Set to NA to disregard (default) or provide a single numeric value (cutoff will be applied symetrically for both up- and down-regulated)
#' @param qvalue_threshold Q-value threshold for significant hits. Set to NA to disregard (default), otherwise it is assumed the input data table contains a boolean column 'signif'
#' @param mtitle optionally, a title for the plot
#' @param label_mode which class of proteins should be labeled in the plot. Options: topn_pvalue (top N smallest p-value, default), signif (all significant proteins), protein_id (a provided set of protein_id). Defaults to topN for consistency and clarity; if the upstream analysis yielded hundreds of hits the labels will be unreadable
#' @param label_target further specification of the label_mode parameter. For instance, if 'topn_pvalue' is set, here you can set the number of proteins that should be labeled. Analogously, if label_mode='protein_id' is set you can here provide an array of protein_id values (that are available in the stats_de data table)
#' @param label_avoid_overlap use the ggrepel R package to try and place labels with minimal overlap (only works when the number of labeled proteins is relatively low and sparse, e.g. for topN 25). Options: TRUE, FALSE
#' @return returns a named list that contains a list, with properties 'ggplot' and 'ggplot_data', for each unique 'dea_algorithm' in the input stats_de table
#'
#' @examples
#' ### Exampes. Note that these assume that prior, the MS-DAP pipeline was successfully run
#' # using `dataset = analysis_quickstart(...)`.
#' # If your dataset contains multiple contrasts, follow example 5
#'
#' ## example 1: add protein-metadata to the DEA results (dataset$de_proteins), plotting the
#' # top 10 'best pvalue' hits while hardcoding the cutoffs for foldchange and Q-value
#' \dontrun{
#'   plot_list = msdap::plot_volcano(dataset$de_proteins %>% left_join(dataset$proteins),
#'     log2foldchange_threshold = 1, qvalue_threshold = 0.01,
#'     mtitle = "volcano, label top 10", label_mode = "topn_pvalue", label_target = 10,
#'     label_avoid_overlap = TRUE
#'   )
#'   # for each unique 'dea_algorithm' in the stats_de table, list of ggplot objects and data
#'   lapply(plot_list, "[[", "ggplot")
#' }
#'
#' ## example 2: analogous, but now show all significant proteins and disable "repelled labels"
#' # (instead, print protein labels just below each data point)
#' \dontrun{
#'   plot_list = msdap::plot_volcano(dataset$de_proteins %>% left_join(dataset$proteins),
#'     log2foldchange_threshold = 1, qvalue_threshold = 0.01,
#'     mtitle = "volcano, label all significant", label_mode = "signif",
#'     label_avoid_overlap = FALSE
#'   )
#'   lapply(plot_list, "[[", "ggplot")
#' }
#'
#' ## example 3: show labels for some set of protein IDs. First line selects all proteins where symbol
#' # starts with GRIA or DLG (arbitrary example, either adapt the regex or use other filters/criteria
#' # to define a subset of protein_id from your dataset). Second line shows how to specify protein_id
#' # to be used as a label
#' \dontrun{
#'   pid_label = dataset$proteins %>%
#'     filter(grepl("^(GRIA|DLG)", gene_symbols_or_id, ignore.case=T)) %>% pull(protein_id)
#'   plot_list = msdap::plot_volcano(dataset$de_proteins %>% left_join(dataset$proteins),
#'     log2foldchange_threshold = 1, qvalue_threshold = 0.01,
#'     mtitle = "volcano, label selected proteins", label_mode = "protein_id",
#'     label_target = pid_label, label_avoid_overlap = FALSE
#'   )
#'   lapply(plot_list, "[[", "ggplot")
#' }
#'
#' ## example 4: plot all significant labels as before, then add custom labels for some subset of
#' # proteins (we here regex select some labels in the plot, you should adapt the regex to match
#' # some proteins in your dataset to make this work, but you can also further filter by other
#' # properties in the 'ggplot_data' tibble like the y-coordinate aka qvalue)
#' \dontrun{
#'   plot_list = msdap::plot_volcano(dataset$de_proteins %>% left_join(dataset$proteins),
#'     log2foldchange_threshold = 1, qvalue_threshold = 0.01, mtitle = "volcano,
#'     label all significant + custom labels", label_mode = "signif",
#'     label_avoid_overlap = FALSE
#'   )
#'   l = plot_list[[1]]
#'   l$ggplot + ggrepel::geom_text_repel(
#'     alpha=1, color="green", data = l$ggplot_data %>%
#'       filter(plottype %in% c("asis_lab", "lim_lab") & grepl("^(GRIA|DLG)", label, ignore.case=T)),
#'     segment.alpha = 0.3, min.segment.length = unit(0.25, 'lines'),
#'     vjust = 0.6, show.legend = FALSE, size = 2
#'   )
#' }
#'
#' # example 5: iterate over contrasts before calling plot_volcano()
#' \dontrun{
#'   contrasts = unique(dataset$de_proteins$contrast)
#'   for(contr in contrasts) {
#'     # subset the DEA results for the current contrast
#'     tib_volcano = dataset$de_proteins %>% filter(contrast==contr) %>% left_join(dataset$proteins)
#'
#'     # volcano plot function (compared to above example, now include the contrast in the title)
#'     plot_list = msdap::plot_volcano(tib_volcano, log2foldchange_threshold = 1,
#'       qvalue_threshold = 0.01, mtitle = paste(contr, "volcano, label top 10"),
#'       label_mode = "topn_pvalue", label_target = 10, label_avoid_overlap = TRUE
#'     )
#'
#'     # grab ggplot objects and print plot
#'     ggplot_list = lapply(plot_list, "[[", "ggplot")
#'     for(p in ggplot_list) {
#'       print(p)
#'     }
#'   }
#' }
#'
#' @importFrom ggrepel geom_text_repel
#' @export
plot_volcano = function(stats_de, log2foldchange_threshold = NA, qvalue_threshold = NA, mtitle = "", label_mode = "topn_pvalue", label_target = 25, label_avoid_overlap = TRUE) {
  if(!is.data.frame(stats_de) || nrow(stats_de) == 0) {
    return(list())
  }

  # input validation
  stopifnot(length(label_mode) == 1 && label_mode %in% c("topn_pvalue", "signif", "protein_id"))
  stopifnot(!(label_mode == "topn_pvalue" && !is.finite(label_target))) # if labeling 'top N best pvalue', must specify an integer amount
  stopifnot(!(label_mode == "protein_id" && !all(is.character(label_target))) ) # if labeling protein_id, these must all be strings
  # note; for label_mode="signif" setting the label_target parameter is ignored so we don't have to input validate it

  # replace invalid input with NA (0 is invalid input, as it doesn't filter/discard anything)
  if(length(log2foldchange_threshold) != 1 || !is.finite(log2foldchange_threshold) || log2foldchange_threshold == 0) {
    log2foldchange_threshold = NA
  }
  if(length(qvalue_threshold) != 1 || !is.finite(qvalue_threshold) || qvalue_threshold == 0) {
    qvalue_threshold = NA
  }

  # iterating over contrasts should be done upstream
  if("contrast" %in% names(stats_de) && n_distinct(stats_de$contrast) != 1) {
    append_log("stats_de parameter contains more than 1 unique contrast. If your DEA results contain multiple contrasts, iterative over these and call this volcano plot function for clean subsets of data that only contain stats for 1 contrast", type = "error")
  }


  ########### format input data
  stats_de$pvalue[!is.finite(stats_de$pvalue)] = NA
  stats_de$qvalue[!is.finite(stats_de$qvalue)] = NA

  # optionally, if the user wants to re-define the qvalue cutoff for this plot, do that first. Next, optionally take all significant hits and add filtering by foldchange
  if(!is.na(qvalue_threshold)) {
    stats_de = stats_de %>% mutate(signif = is.finite(qvalue) & qvalue <= qvalue_threshold)
  }
  if(!"signif" %in% colnames(stats_de) || !all(stats_de$signif %in% c(T,F))) {
    append_log("stats_de parameter must contain a column 'signif', or provide a numeric value for parameter 'qvalue_threshold'", type = "error")
  }
  if(!is.na(log2foldchange_threshold)) {
    log2foldchange_threshold = abs(log2foldchange_threshold)
    stats_de = stats_de %>% mutate(signif = signif & abs(foldchange.log2) >= log2foldchange_threshold)
  }

  ## pretty-print labels
  stats_de = add_protein_prettyprint_label(stats_de)


  ########### create volcano plots

  result = list()
  for (algo_name in unique(stats_de$dea_algorithm)) { #algo_name = "ebayes"
    # prepare data for current contrast
    tib = stats_de %>%
      filter(dea_algorithm == algo_name) %>%
      drop_na(foldchange.log2, pvalue, qvalue) %>%
      # minlog10 conversion must be performed within this loop! scales zero's to max-value, ONLY valid within same statistical test
      mutate(minlog10qval = minlog10(qvalue),
             foldchange.log2_abs = abs(foldchange.log2)) %>%
      # order by p-value so we draw the most significant proteins last (thus their symbols/PCH are on top)
      arrange(desc(pvalue)) %>%
      # reduce tibble size
      select(protein_id, label, foldchange.log2, foldchange.log2_abs, minlog10qval, signif)

    # which proteins should get a text label?
    tib$flag_plot_label = FALSE
    lbl_style = ""
    if(label_mode == "signif") { # all significant proteins
      tib$flag_plot_label = tib$signif == TRUE
      lbl_style = "significant"
    }
    if(label_mode == "topn_pvalue") { # topN 'best' pvalue
      tib$flag_plot_label = rep(c(F,T), c(nrow(tib) - label_target, label_target)) # set last N rows to TRUE, this works because we just sorted `tib` by pvalue descending
      lbl_style = paste(label_target, "best qvalue")
    }
    if(label_mode == "protein_id") { # user-specified protein(group) IDs
      tib$flag_plot_label = tib$protein_id %in% label_target
      lbl_style = "selected proteins"
    }

    # classify up/down regulated
    tib$updown = ifelse(tib$foldchange.log2 < 0, "down", "up")
    tib$updown[tib$signif != TRUE] = "unchanged"

    ### find outliers, values that are so far away that they may skew the plot's appearance, and classify data points accordingly
    xmax_nooutlier = c(-1,1) * max(tib$foldchange.log2_abs, na.rm = T)
    ymax_nooutlier = c(0, max(2, tib$minlog10qval, na.rm=T)) # hardcoded limit; y-axis data goes to 10^-2 at least
    xmax = c(-1,1) * max(abs(quantile(tib$foldchange.log2, probs = c(.005, .995), na.rm = T)))
    ymax = c(0, max(2, quantile(tib$minlog10qval, probs = .995, na.rm = T))) # hardcoded limit; y-axis data goes to 10^-2 at least

    tib$isoutlier_x_low = tib$foldchange.log2 < xmax[1]
    tib$isoutlier_x_high = tib$foldchange.log2 > xmax[2]
    tib$isoutlier_y = tib$minlog10qval > ymax[2]

    tib$x_outlier = tib$foldchange.log2
    tib$y_outlier = tib$minlog10qval
    tib$x_outlier[tib$isoutlier_x_low] = xmax[1]
    tib$x_outlier[tib$isoutlier_x_high] = xmax[2]
    tib$y_outlier[tib$isoutlier_y] = ymax[2]

    tib$updown_outlier = tib$updown
    tib$updown_outlier[tib$updown == "unchanged" & (tib$isoutlier_x_low | tib$isoutlier_x_high | tib$isoutlier_y)] = "unchanged_outlier"
    tib$updown_outlier[tib$updown == "down" & (tib$isoutlier_x_low | tib$isoutlier_y)] = "down_outlier"
    tib$updown_outlier[tib$updown == "up" & (tib$isoutlier_x_high | tib$isoutlier_y)] = "up_outlier"

    ### construct facets

    plottype_labels = c(asis = "data as-is, no labels",
                        asis_lab = paste("data as-is, label", lbl_style),
                        lim = "limited x- and y-axis, no labels",
                        lim_lab = paste("limited x- and y-axis, label", lbl_style))

    tib_facets = bind_rows(tib %>% select(label, x=foldchange.log2, y=minlog10qval, pch=updown, flag_plot_label) %>% mutate(flag_plot_label=FALSE) %>% add_column(plottype = "asis"),
                           tib %>% select(label, x=foldchange.log2, y=minlog10qval, pch=updown, flag_plot_label)                                   %>% add_column(plottype = "asis_lab"),
                           tib %>% select(label, x=x_outlier, y=y_outlier, pch=updown_outlier, flag_plot_label) %>% mutate(flag_plot_label=FALSE)  %>% add_column(plottype = "lim"),
                           tib %>% select(label, x=x_outlier, y=y_outlier, pch=updown_outlier, flag_plot_label)                                    %>% add_column(plottype = "lim_lab"))
    tib_facets$pch = factor(tib_facets$pch, levels = c("down", "unchanged", "up", "down_outlier", "unchanged_outlier", "up_outlier"))

    # some mock data to enforce symmetric x-axis and expand the y-limit a bit to make room for the labels (this is a workaround because we cannot hardcode separate y-axis limits per facet)
    blank_data = bind_rows(tibble(x=xmax_nooutlier, y=ymax_nooutlier[2] * 1.2, plottype = "asis"),
                           tibble(x=xmax_nooutlier, y=ymax_nooutlier[2] * 1.2, plottype = "asis_lab"),
                           tibble(x=xmax, y=ymax[2] * 1.2, plottype = "lim"),
                           tibble(x=xmax, y=ymax[2] * 1.2, plottype = "lim_lab") ) %>%
      add_column(pch="unchanged", label="")

    ### volcano plot
    p = ggplot(tib_facets, aes(x, y, colour = pch, fill = pch, shape = pch, label = label)) +
      geom_point(na.rm=T) +
      geom_blank(data = blank_data) +
      scale_discrete_manual(
        aesthetics = c("colour", "fill"),
        values = c(up = "#d55e00aa", down = "#56b4e9aa", up_outlier = "#d55e00aa", down_outlier = "#56b4e9aa", unchanged = "#22222299", unchanged_outlier = "#22222299"),
        labels = c(up = "up regulated", down = "down regulated", up_outlier = "up regulated & outside plot limits", down_outlier = "down regulated & outside plot limits",
                   unchanged = "not significant", unchanged_outlier = "not significant & outside plot limits"),
        drop = F,
        guide = guide_legend(byrow=F, override.aes = list(alpha = 1))
      ) +
      scale_shape_manual(values = c(up = 24, down = 25, up_outlier = 2, down_outlier = 6, unchanged = 19, unchanged_outlier = 1),
                         labels = c(up = "up regulated", down = "down regulated", up_outlier = "up regulated & outside plot limits", down_outlier = "down regulated & outside plot limits",
                                    unchanged = "not significant", unchanged_outlier = "not significant & outside plot limits"),
                         drop = F
      ) +
      facet_wrap(~plottype, nrow = 2, ncol = 2, scales = "free", labeller = labeller(plottype=plottype_labels)) +
      labs(x = "log2 fold-change", y = "-log10 FDR adjusted p-value", title = paste(algo_name, "@", mtitle)) +
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5, size=8),
            legend.position = "bottom",
            legend.title = element_blank(),
            legend.text = element_text(size=8))

    if(any(tib_facets$flag_plot_label)) {
      if(label_avoid_overlap) {
        p = p + ggrepel::geom_text_repel(data = tib_facets %>% filter(flag_plot_label == TRUE), alpha=1, # vjust = 0.6,
                                         show.legend = FALSE, size = 2, segment.alpha = .3, min.segment.length = 0, na.rm = TRUE, max.time = 1, max.iter = 1e5, max.overlaps = Inf, point.padding = 0, box.padding = 0.2, seed = 123) # min.segment.length = unit(0.2, 'lines')
      } else {
        p = p + geom_text(alpha=1, data = tib_facets %>% filter(flag_plot_label == TRUE), vjust = 1.1, show.legend = FALSE, size = 2)
      }
    }

    if(!is.na(log2foldchange_threshold)) {
      p = p + geom_vline(xintercept = c(-1,1) * log2foldchange_threshold, colour = "darkgrey", linetype = "dashed")
    }
    if(!is.na(qvalue_threshold)) {
      p = p + geom_hline(yintercept = -log10(qvalue_threshold), colour = "darkgrey", linetype = "dashed")
    }

    result[[algo_name]] = list(ggplot = p, ggplot_data = tib_facets)
  }

  return(result)
}



#' placeholder title
#' @param tib pre-define color_code column
#' @param mtitle todo
plot_foldchanges = function(tib, mtitle="") {
  if(!is.data.frame(tib) || nrow(tib) == 0) {
    return(NULL)
  }

  ggplot(tib, aes(foldchange.log2, colour = color_code)) +
    geom_vline(xintercept=0) +
    # same density function as default in base R's stats::density()
    geom_line(stat = "density", adjust=1, bw = "SJ", na.rm = T) +
    facet_wrap( ~ dea_algorithm, nrow = ceiling(sqrt(n_distinct(tib$color_code))), scales = "free_y") +
    coord_cartesian(xlim = c(-1,1) * max(abs(quantile(tib$foldchange.log2, probs = c(0.005, 0.995), na.rm=T)))) +
    labs(x="log2 foldchange", colour = "", title=mtitle) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5, size=8),
          legend.position = "none") # bottom

  ### alternatively, combine into a single plot. Since some methods (eg; msqrob) can hugely inflate the amount of proteins with exactly zero foldchange this can distort the binning and y-axis scale. So above plot with separate facets (and ditto free scales) is preferred
  # ggplot(tib, aes(x = foldchange.log2, colour=color_code)) +
  #   geom_vline(xintercept=0) +
  #   stat_density(adjust=3, bw = "SJ", geom="line", na.rm=T, trim=F) + # aes(y = ..count..) seems scuffed, way to many
  #   coord_cartesian(xlim = c(-1,1) * mean(abs(quantile(tib$foldchange.log2, probs = c(0.005, 0.995), na.rm=T)))) +
  #   labs(x="log2 foldchange", colour = "", title=mtitle) +
  #   theme_bw() +
  #   theme(legend.position = "bottom")
}



#' placeholder title
#' @param tib todo
#' @param mtitle todo
plot_pvalue_histogram = function(tib, mtitle="") {
  if(!is.data.frame(tib) || nrow(tib) == 0) {
    return(NULL)
  }
  # debug_tib_pvalue_hist <<- tib
  binwidth = 0.05
  tib_summ = tib %>% filter(is.finite(pvalue)) %>% group_by(dea_algorithm) %>% summarise(yintercept_line = binwidth * n())

  ggplot(tib, aes(pvalue)) +
    geom_histogram(binwidth = binwidth, boundary = 0, colour = "white", fill="darkgrey", na.rm=T) +
    geom_hline(data = tib_summ, aes(yintercept = yintercept_line), colour = "darkblue") +
    scale_x_continuous(breaks = (0:10)/10, minor_breaks = (0:5)/5) +
    facet_wrap( ~ dea_algorithm, nrow = 2, scales = "fixed") +
    labs(x="p-value", y="number of proteins", colour = "", title=mtitle) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5, size=8),
          legend.position = "none")
}
